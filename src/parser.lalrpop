use ast;
use lexer;
use std::str::FromStr;

grammar<'input>;

pub Module: ast::Module = {
    <ModuleBlock> => ast::Module::Root {
        items: <>,
    }
};

ModuleBlock = <Item*>;

Item: ast::Item = {
    <MOD_DOC_COMMENT> => ast::Item::ModuleDocComment(<>.into()),
    <DOC_COMMENT> => ast::Item::DocComment(<>.into()),

    "use" <Expression> ";" => ast::Item::Use(<>),
    "extern" "mod" <Identifier> ";" => ast::Item::Extern(<>),
    "mod" <Identifier> => ast::Item::Module(ast::Module::Extern { name: <> }),
    "mod" <name:Identifier> "{" <items:ModuleBlock> "}" => ast::Item::Module(ast::Module::Inline {
        name: name,
        items: items,
    }),
    "type" <Identifier> ";" => ast::Item::TypeDecl(<>),
    "impl" <inter:(<Identifier> "for")?> <name:Identifier> "{" <methods:("fn" <Function>)*> "}" => {
        let mut methods = methods;
        for func in methods.iter_mut() {
            if let Some("self") = func.parameters.first().map(|s| &s[..]) {
                func.parameters.remove(0);
                func.is_member = true;
            }
        }
        ast::Item::TypeImpl(ast::TypeImpl {
            name: name,
            interface: inter,
            methods: methods,
        })
    },
    "trait" <name:Identifier> "{" <methods:("fn" <TraitFunction>)*> "}" => {
        let mut methods = methods;
        for func in methods.iter_mut() {
            if let Some("self") = func.parameters.first().map(|s| &s[..]) {
                func.parameters.remove(0);
                func.is_member = true;
            }
        }
        ast::Item::Trait(ast::Trait {
            name: name,
            methods: methods,
        })
    },
    "fn" <Function> => ast::Item::Function(<>),
};

Params = Comma<Identifier>;
Function: ast::Function = {
    <name:Identifier> "(" <params:Params> ")" <err_flag:("?")?> <body:Block> => ast::Function {
        name: name.into(),
        parameters: params,
        can_error: err_flag.is_some(),
        is_member: false,
        body: body,
    }
};

TraitFunction: ast::TraitFunction = {
    <name:Identifier> "(" <params:Params> ")" <err_flag:("?")?> ";" => ast::TraitFunction {
        name: name.into(),
        parameters: params,
        can_error: err_flag.is_some(),
        is_member: false,
    }
};

Block: ast::Block = {
    "{" <Statement*> "}" => ast::Block {
        statements: <>,
    }
};

Statement: ast::Statement = {
    "let" <Identifier> <("," <Identifier>)*> <("=" <Expression>)?> ";" => ast::Statement::Declaration(<>),
    "return" <Expression> <("," <Expression>)*> ";" => ast::Statement::Return(<>),
    "throw" <Expression> ";" => ast::Statement::Throw(<>),
    "use" <Expression> ";" => ast::Statement::Use(<>),
    "if" <IfBlockChain> => ast::Statement::IfElse(<>),
    "break" <Label?> ";" => ast::Statement::Break(<>),
    "continue" <Label?> ";" => ast::Statement::Continue(<>),

    <(<Label> ":")?> "loop" <Block> => {
        let (label, block) = (<>);
        let iloop = ast::Loop {
            label: label,
            block: block,
        };
        ast::Statement::Loop(iloop)
    },

    <(<Label> ":")?> "for" <Identifier> <("," <Identifier>)*> "in" <Expression> <Block> => {
        let (label, id, mut bindings, iter, block) = (<>);
        bindings.insert(0, id);
        let for_loop = ast::ForLoop {
            label: label,
            bindings: bindings,
            iterator: iter,
            block: block,
        };
        ast::Statement::ForLoop(for_loop)
    },

    <(<Label> ":")?> "while" <Expression> <Block> => {
        let (label, condition, block) = (<>);
        let while_loop = ast::WhileLoop {
            label: label,
            condition: condition,
            block: block,
        };
        ast::Statement::WhileLoop(while_loop)
    },

    <MemberAccess> <("," <MemberAccess>)*> <AssignOps> <Expression> ";" => ast::Statement::Assignment(<>),
    <FunctionCall> ";" => ast::Statement::Expression(<>),
};

AssignOps: ast::AssignOp = {
    "=" => ast::AssignOp::Assign,
    "||=" => ast::AssignOp::LogicalOr,
    "&&=" => ast::AssignOp::LogicalAnd,
    "|=" => ast::AssignOp::BitOr,
    "&=" => ast::AssignOp::BitAnd,
    "^=" => ast::AssignOp::BitXor,
    "<<=" => ast::AssignOp::LShiftLeft,
    ">>=" => ast::AssignOp::AShiftRight,
    ">>>=" => ast::AssignOp::LShiftRight,
    "+=" => ast::AssignOp::Add,
    "-=" => ast::AssignOp::Sub,
    "*=" => ast::AssignOp::Mul,
    "/=" => ast::AssignOp::Div,
    "%=" => ast::AssignOp::Rem,
    "mod=" => ast::AssignOp::Mod,
};

IfBlockChain: ast::IfElse = {
    <cond:Expression> <if_block:Block> => ast::IfElse {
        condition: Box::new(cond),
        if_block: Box::new(if_block),
        else_block: None,
    },
    <cond:Expression> <if_block:Block> "else" <else_block:Block> => ast::IfElse {
        condition: Box::new(cond),
        if_block: Box::new(if_block),
        else_block: Some(Box::new(else_block)),
    },
    <cond:Expression> <if_block:Block> "else" "if" <chain:IfBlockChain> => ast::IfElse {
        condition: Box::new(cond),
        if_block: Box::new(if_block),
        else_block: Some(Box::new(ast::Block {
            statements: vec![ast::Statement::IfElse(chain)],
        })),
    }
};

Expression: ast::Expression = {
    "new_object" <Identifier> <ObjectLiteral> => ast::Expression::ObjectConstructor(<>),
    <Expression> "?" => ast::Expression::Try(Box::new(<>)),
    FunctionCall,

    BinaryOperators,
};

FunctionCall: ast::Expression = {
    <func:MemberAccess> "(" <params:Comma<Expression>> ")" => {
        ast::Expression::FunctionCall(Box::new(func), params)
    },
};

ImplOp: ast::BinOp = {
    "impls" => ast::BinOp::Implements,
};

RangeOps: ast::BinOp = {
    ".." => ast::BinOp::RangeExclusive,
    "..." => ast::BinOp::RangeInclusive,
};

LogicalOr: ast::BinOp = {
    "||" => ast::BinOp::LogicalOr
};

LogicalAnd: ast::BinOp = {
    "&&" => ast::BinOp::LogicalAnd
};

EqualOps: ast::BinOp = {
    "==" => ast::BinOp::Equal,
    "!=" => ast::BinOp::NotEqual,
    "<" => ast::BinOp::LessThan,
    ">" => ast::BinOp::GreaterThan,
    "<=" => ast::BinOp::LessOrEqual,
    ">=" => ast::BinOp::GreaterOrEqual,
};

BitOps: ast::BinOp = {
    "&" => ast::BinOp::BitAnd,
    "|" => ast::BinOp::BitOr,
    "^" => ast::BinOp::BitXor,
};

ShiftOps: ast::BinOp = {
    "<<" => ast::BinOp::LShiftLeft,
    ">>" => ast::BinOp::AShiftRight,
    ">>>" => ast::BinOp::LShiftRight,
};

AddSubOps: ast::BinOp = {
    "+" => ast::BinOp::Add,
    "-" => ast::BinOp::Sub,
};

MulDivOps: ast::BinOp = {
    "*" => ast::BinOp::Mul,
    "/" => ast::BinOp::Div,
    "%" => ast::BinOp::Rem,
    "/%" => ast::BinOp::DivRem,
    "mod" => ast::BinOp::Mod,
};

BinaryOperators = ImplOperator;
ImplOperator = Tier<ImplOp, RangeOperators>;
RangeOperators = Tier<RangeOps, LogicalOperators>;
LogicalOperators = Tier<LogicalOr, Tier<LogicalAnd, EqualityOperators>>;
EqualityOperators = Tier<EqualOps, BitwiseOperators>;
BitwiseOperators = Tier<BitOps, ShiftOperators>;
ShiftOperators = Tier<ShiftOps, AddSubOperators>;
AddSubOperators = Tier<AddSubOps, MulDivOperators>;
MulDivOperators = Tier<MulDivOps, UnaryOperators>;

UnaryOperators: ast::Expression = {
    "-" <UnaryOperators> => ast::Expression::Negate(Box::new(<>)),
    "!" <UnaryOperators> => ast::Expression::Not(Box::new(<>)),
    "-" <FunctionCall> => ast::Expression::Negate(Box::new(<>)),
    "!" <FunctionCall> => ast::Expression::Not(Box::new(<>)),
    MemberAccess,
};

MemberAccess: ast::Expression = {
    <obj:MemberAccess> "[" <index:Expression> "]" => {
        ast::Expression::IndexAccess(Box::new(obj), Box::new(index))
    },
    <obj:MemberAccess> "." <member:Identifier> => {
        ast::Expression::MemberAccess(Box::new(obj), member)
    },
    <obj:FunctionCall> "." <member:Identifier> => {
        ast::Expression::MemberAccess(Box::new(obj), member)
    },
    Term
};

Term: ast::Expression = {
    <Literal> => ast::Expression::Literal(<>),
    <Identifier> => ast::Expression::Identifier(<>),
    "(" <Expression> ")",
    "nil" => ast::Expression::Nil,
};

Literal: ast::Literal = {
    INT_LITERAL => ast::Literal::Integer(i64::from_str(<>).unwrap()),
    FLOAT_LITERAL => ast::Literal::Float(f64::from_str(<>).unwrap()),
    // TODO: Parse string literal into actual string data
    STR_LITERAL => ast::Literal::String(<>.into()),
    <ObjectLiteral> => ast::Literal::Object(<>),
    <ArrayLiteral> => ast::Literal::Array(<>),
};

ObjectLiteral: ast::ObjectLiteral = {
    "{" <Comma<BlockItem>> "}" => (<>).into_iter().collect()
};

ArrayLiteral = "[" <Comma<Expression>> "]";

BlockItem: (ast::Identifier, ast::Expression) = {
    <Identifier> ":" <Expression> => (<>),
    <Identifier> => (<>.clone(), ast::Expression::Identifier(<>.clone())),
};

Identifier: String = IDENTIFIER => <>.into();
Label: String = LABEL => (<>[1..]).into();

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Tier<Op, NextTier>: ast::Expression = {
    <l:Tier<Op, NextTier>> <o:Op> <r:NextTier> => {
        ast::Expression::BinaryOp(Box::new(l), o, Box::new(r))
    },
    NextTier
};

extern {
    type Location = lexer::Location;
    type Error = lexer::LexicalError;

    enum lexer::Tok<'input> {
        "break" => (lexer::TokenType::Break, _),
        "continue" => (lexer::TokenType::Continue, _),
        "else" => (lexer::TokenType::Else, _),
        "enum" => (lexer::TokenType::Enum, _),
        "extern" => (lexer::TokenType::Extern, _),
        "fn" => (lexer::TokenType::Function, _),
        "for" => (lexer::TokenType::For, _),
        "if" => (lexer::TokenType::If, _),
        "impl" => (lexer::TokenType::Impl, _),
        "impls" => (lexer::TokenType::Impls, _),
        "in" => (lexer::TokenType::In, _),
        "let" => (lexer::TokenType::Let, _),
        "loop" => (lexer::TokenType::Loop, _),
        "mod" => (lexer::TokenType::Mod, _),
        "new_object" => (lexer::TokenType::NewObject, _),
        "nil" => (lexer::TokenType::Nil, _),
        "return" => (lexer::TokenType::Return, _),
        "throw" => (lexer::TokenType::Throw, _),
        "trait" => (lexer::TokenType::Trait, _),
        "type" => (lexer::TokenType::Type, _),
        "use" => (lexer::TokenType::Use, _),
        "while" => (lexer::TokenType::While, _),

        "{" => (lexer::TokenType::OpenCurly, _),
        "}" => (lexer::TokenType::CloseCurly, _),
        "(" => (lexer::TokenType::OpenParen, _),
        ")" => (lexer::TokenType::CloseParen, _),
        "[" => (lexer::TokenType::OpenBracket, _),
        "]" => (lexer::TokenType::CloseBracket, _),
        ";" => (lexer::TokenType::Semicolon, _),
        ":" => (lexer::TokenType::Colon, _),
        "," => (lexer::TokenType::Comma, _),
        "?" => (lexer::TokenType::Question, _),
        "." => (lexer::TokenType::Dot, _),

        ".." => (lexer::TokenType::RangeExclusive, _),
        "..." => (lexer::TokenType::RangeInclusive, _),

        "==" => (lexer::TokenType::Equal, _),
        "!=" => (lexer::TokenType::NotEqual, _),
        "<" => (lexer::TokenType::LessThan, _),
        "<=" => (lexer::TokenType::LessOrEqual, _),
        ">" => (lexer::TokenType::GreaterThan, _),
        ">=" => (lexer::TokenType::GreaterOrEqual, _),

        "!" => (lexer::TokenType::Not, _),

        "&&" => (lexer::TokenType::LogicalAnd, _),
        "||" => (lexer::TokenType::LogicalOr, _),
        "&&=" => (lexer::TokenType::LogicalAndAssign, _),
        "||=" => (lexer::TokenType::LogicalOrAssign, _),

        "+" => (lexer::TokenType::Add, _),
        "-" => (lexer::TokenType::Sub, _),
        "*" => (lexer::TokenType::Mul, _),
        "/" => (lexer::TokenType::Div, _),
        "%" => (lexer::TokenType::Rem, _),
        "/%" => (lexer::TokenType::DivRem, _),
        "&" => (lexer::TokenType::BitAnd, _),
        "|" => (lexer::TokenType::BitOr, _),
        "^" => (lexer::TokenType::BitXor, _),
        "<<" => (lexer::TokenType::Shl, _),
        ">>" => (lexer::TokenType::Shr, _),
        ">>>" => (lexer::TokenType::LShr, _),

        "=" => (lexer::TokenType::Assign, _),
        "+=" => (lexer::TokenType::AddAssign, _),
        "-=" => (lexer::TokenType::SubAssign, _),
        "*=" => (lexer::TokenType::MulAssign, _),
        "/=" => (lexer::TokenType::DivAssign, _),
        "%=" => (lexer::TokenType::RemAssign, _),
        "&=" => (lexer::TokenType::BitAndAssign, _),
        "|=" => (lexer::TokenType::BitOrAssign, _),
        "^=" => (lexer::TokenType::BitXorAssign, _),
        "<<=" => (lexer::TokenType::ShlAssign, _),
        ">>=" => (lexer::TokenType::ShrAssign, _),
        ">>>=" => (lexer::TokenType::LShrAssign, _),
        "mod=" => (lexer::TokenType::ModAssign, _),

        DOC_COMMENT => (lexer::TokenType::DocComment, <&'input str>),
        MOD_DOC_COMMENT => (lexer::TokenType::ModuleDocComment, <&'input str>),
        IDENTIFIER => (lexer::TokenType::Identifier, <&'input str>),
        INT_LITERAL => (lexer::TokenType::IntLiteral, <&'input str>),
        HEX_LITERAL => (lexer::TokenType::HexLiteral, <&'input str>),
        OCT_LITERAL => (lexer::TokenType::OctLiteral, <&'input str>),
        BIN_LITERAL => (lexer::TokenType::BinLiteral, <&'input str>),
        FLOAT_LITERAL => (lexer::TokenType::FloatLiteral, <&'input str>),
        STR_LITERAL => (lexer::TokenType::StringLiteral, <&'input str>),
        CHAR_LITERAL => (lexer::TokenType::CharLiteral, <&'input str>),
        LABEL => (lexer::TokenType::Label, <&'input str>),
    }
}
