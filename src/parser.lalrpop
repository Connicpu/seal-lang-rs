use ast;
use std::str::FromStr;

grammar;

pub Module: ast::Module = {
    <ModuleBlock> => ast::Module::Root {
        items: <>,
    }
};

ModuleBlock = <Item*>;

Item: ast::Item = {
    "use" <Expression> ";" => ast::Item::Use(<>),
    "extern" "mod" <Identifier> ";" => ast::Item::Extern(<>),
    "mod" <Identifier> => ast::Item::Module(ast::Module::Extern { name: <> }),
    "mod" <name:Identifier> "{" <items:ModuleBlock> "}" => ast::Item::Module(ast::Module::Inline {
        name: name,
        items: items,
    }),
    "type" <Identifier> ";" => ast::Item::TypeDecl(<>),
    "impl" <inter:(<Identifier> "for")?> <name:Identifier> "{" <methods:("fn" <Function>)*> "}" => {
        let mut methods = methods;
        for func in methods.iter_mut() {
            if let Some("self") = func.parameters.first().map(|s| &s[..]) {
                func.parameters.remove(0);
                func.is_member = true;
            }
        }
        ast::Item::TypeImpl(ast::TypeImpl {
            name: name,
            interface: inter,
            methods: methods,
        })
    },
    "trait" <name:Identifier> "{" <methods:("fn" <TraitFunction>)*> "}" => {
        let mut methods = methods;
        for func in methods.iter_mut() {
            if let Some("self") = func.parameters.first().map(|s| &s[..]) {
                func.parameters.remove(0);
                func.is_member = true;
            }
        }
        ast::Item::Trait(ast::Trait {
            name: name,
            methods: methods,
        })
    },
    "fn" <Function> => ast::Item::Function(<>),
};

Params = Comma<Identifier>;
ErrFlag: bool = {
    ")?" => true,
    ")" => false,
};
Function: ast::Function = {
    <name:Identifier> "(" <params:Params> <err_flag:ErrFlag> <body:Block> => ast::Function {
        name: name.into(),
        parameters: params,
        can_error: err_flag,
        is_member: false,
        body: body,
    }
};

TraitFunction: ast::TraitFunction = {
    <name:Identifier> "(" <params:Params> <err_flag:ErrFlag> ";" => ast::TraitFunction {
        name: name.into(),
        parameters: params,
        can_error: err_flag,
        is_member: false,
    }
};

Block: ast::Block = {
    "{" <Statement*> "}" => ast::Block {
        statements: <>,
    }
};

Statement: ast::Statement = {
    "let" <Identifier> <("," <Identifier>)*> <("=" <Expression>)?> ";" => ast::Statement::Declaration(<>),
    "return" <Expression> <("," <Expression>)*> ";" => ast::Statement::Return(<>),
    "throw" <Expression> ";" => ast::Statement::Throw(<>),
    "use" <Expression> ";" => ast::Statement::Use(<>),
    "if" <IfBlockChain> => ast::Statement::IfElse(<>),

    "for" <Identifier> <("," <Identifier>)*> "in" <Expression> <Block> => {
        let (id, mut bindings, iter, block) = (<>);
        bindings.insert(0, id);
        let for_loop = ast::ForLoop {
            bindings: bindings,
            iterator: iter,
            block: block,
        };
        ast::Statement::ForLoop(for_loop)
    },

    <MemberAccess> <("," <MemberAccess>)*> <AssignOps> <Expression> ";" => ast::Statement::Assignment(<>),
    <FunctionCall> ";" => ast::Statement::Expression(<>),
};

AssignOps: ast::AssignOp = {
    "=" => ast::AssignOp::Assign,
    "|=" => ast::AssignOp::BitOr,
    "&=" => ast::AssignOp::BitAnd,
    "^=" => ast::AssignOp::BitXor,
    "<<=" => ast::AssignOp::LShiftLeft,
    ">>=" => ast::AssignOp::AShiftRight,
    ">>>=" => ast::AssignOp::LShiftRight,
    "+=" => ast::AssignOp::Add,
    "-=" => ast::AssignOp::Sub,
    "*=" => ast::AssignOp::Mul,
    "/=" => ast::AssignOp::Div,
    "%=" => ast::AssignOp::Rem,
};

IfBlockChain: ast::IfElse = {
    <cond:Expression> <if_block:Block> => ast::IfElse {
        condition: Box::new(cond),
        if_block: Box::new(if_block),
        else_block: None,
    },
    <cond:Expression> <if_block:Block> "else" <else_block:Block> => ast::IfElse {
        condition: Box::new(cond),
        if_block: Box::new(if_block),
        else_block: Some(Box::new(else_block)),
    },
    <cond:Expression> <if_block:Block> "else if" <chain:IfBlockChain> => ast::IfElse {
        condition: Box::new(cond),
        if_block: Box::new(if_block),
        else_block: Some(Box::new(ast::Block {
            statements: vec![ast::Statement::IfElse(chain)],
        })),
    }
};

Expression: ast::Expression = {
    "new" <Identifier> <ObjectLiteral> => ast::Expression::ObjectConstructor(<>),
    <Expression> "?" => ast::Expression::Try(Box::new(<>)),
    FunctionCall,

    BinaryOperators,
};

FunctionCall: ast::Expression = {
    <func:MemberAccess> "(" <params:Comma<Expression>> ")" => {
        ast::Expression::FunctionCall(Box::new(func), params)
    },
};

ImplOp: ast::BinOp = {
    "impls" => ast::BinOp::Implements,
};

RangeOps: ast::BinOp = {
    ".." => ast::BinOp::RangeExclusive,
    "..." => ast::BinOp::RangeInclusive,
};

LogicalOr: ast::BinOp = {
    "||" => ast::BinOp::LogicalOr
};

LogicalAnd: ast::BinOp = {
    "&&" => ast::BinOp::LogicalAnd
};

EqualOps: ast::BinOp = {
    "==" => ast::BinOp::Equal,
    "!=" => ast::BinOp::NotEqual,
    "<" => ast::BinOp::LessThan,
    ">" => ast::BinOp::GreaterThan,
    "<=" => ast::BinOp::LessOrEqual,
    ">=" => ast::BinOp::GreaterOrEqual,
};

BitOps: ast::BinOp = {
    "&" => ast::BinOp::BitAnd,
    "|" => ast::BinOp::BitOr,
    "^" => ast::BinOp::BitXor,
};

ShiftOps: ast::BinOp = {
    "<<" => ast::BinOp::LShiftLeft,
    ">>" => ast::BinOp::AShiftRight,
    ">>>" => ast::BinOp::LShiftRight,
};

AddSubOps: ast::BinOp = {
    "+" => ast::BinOp::Add,
    "-" => ast::BinOp::Sub,
};

MulDivOps: ast::BinOp = {
    "*" => ast::BinOp::Mul,
    "/" => ast::BinOp::Div,
    "%" => ast::BinOp::Rem,
};

BinaryOperators = ImplOperator;
ImplOperator = Tier<ImplOp, RangeOperators>;
RangeOperators = Tier<RangeOps, LogicalOperators>;
LogicalOperators = Tier<LogicalOr, Tier<LogicalAnd, EqualityOperators>>;
EqualityOperators = Tier<EqualOps, BitwiseOperators>;
BitwiseOperators = Tier<BitOps, ShiftOperators>;
ShiftOperators = Tier<ShiftOps, AddSubOperators>;
AddSubOperators = Tier<AddSubOps, MulDivOperators>;
MulDivOperators = Tier<MulDivOps, UnaryOperators>;

UnaryOperators: ast::Expression = {
    "-" <UnaryOperators> => ast::Expression::Negate(Box::new(<>)),
    "!" <UnaryOperators> => ast::Expression::Not(Box::new(<>)),
    "-" <FunctionCall> => ast::Expression::Negate(Box::new(<>)),
    "!" <FunctionCall> => ast::Expression::Not(Box::new(<>)),
    MemberAccess,
};

MemberAccess: ast::Expression = {
    <obj:MemberAccess> "[" <index:Expression> "]" => {
        ast::Expression::IndexAccess(Box::new(obj), Box::new(index))
    },
    <obj:MemberAccess> "." <member:Identifier> => {
        ast::Expression::MemberAccess(Box::new(obj), member)
    },
    <obj:FunctionCall> "." <member:Identifier> => {
        ast::Expression::MemberAccess(Box::new(obj), member)
    },
    Term
};

Term: ast::Expression = {
    <Literal> => ast::Expression::Literal(<>),
    <Identifier> => ast::Expression::Identifier(<>),
    "(" <Expression> ")",
    "nil" => ast::Expression::Nil,
};

Literal: ast::Literal = {
    r"[0-9]+" => ast::Literal::Integer(i64::from_str(<>).unwrap()),
    r"[0-9]+\.[0-9]+(e[+-]?[0-9]+)?" => ast::Literal::Float(f64::from_str(<>).unwrap()),
    // TODO: Parse string literal into actual string data
    r#""(\\.|[^"])*""# => ast::Literal::String(<>.into()),
    <ObjectLiteral> => ast::Literal::Object(<>),
    <ArrayLiteral> => ast::Literal::Array(<>),
};

ObjectLiteral: ast::ObjectLiteral = {
    "{" <Comma<BlockItem>> "}" => (<>).into_iter().collect()
};

ArrayLiteral = "[" <Comma<Expression>> "]";

BlockItem: (ast::Identifier, ast::Expression) = {
    <Identifier> ":" <Expression> => (<>),
    <Identifier> => (<>.clone(), ast::Expression::Identifier(<>.clone())),
};

Identifier: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => (<>).into();
//Identifier: String = r"[\p{XID_Start}_][\p{XID_Continue}_]*" => (<>).into();
Label: String = ":" <Identifier>;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Tier<Op, NextTier>: ast::Expression = {
    <l:Tier<Op, NextTier>> <o:Op> <r:NextTier> => {
        ast::Expression::BinaryOp(Box::new(l), o, Box::new(r))
    },
    NextTier
};
